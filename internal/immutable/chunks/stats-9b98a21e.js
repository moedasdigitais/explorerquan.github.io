import{w as h}from"./index-08e0cf00.js";let l;const k={hashRate:0,avgHashrate:0,difficulty:0,avgDifficulty:0,height:0,last_known_block_index:0,transactions:0,emissionPercent:0,supply:0,currentReward:0,blockSolveTime:0,lastuptime:0,blocks:[]},{subscribe:m,update:_}=h(k),b=(t,e)=>t+e,y=t=>{const e=[[60,"segundos"],[60,"minutos"],[24,"horas"],[7,"dias"],[4,"semanas"],[12,"meses"],[1,"anos"]].reverse(),s=(r,i)=>{const a=Math.round(r);return""+a+" "+i+(a>1,"")};let n=t;for(let r=e.length-1;r>=0;r--){const i=e[r];if(i){if(i[0]>n)return s(n,i[1]);n=n/i[0]}if(r===0)return s(n,e[e.length-1][1])}},u=(t,e)=>{let s=0,n=8;return e&&(n=e),t&&(s=parseInt(t)),Number(s/1e8).toFixed(n||9-1)},d=t=>{let e=0;const s=[" H"," kH"," MH"," GH"," TH"," PH"," EH"," ZH"," YH"];for(;t>1e3;)t=t/1e3,e++;return t.toFixed(2)+s[e]},g=(t,e)=>{if(isNaN(parseFloat(t))||!isFinite(t))return 0;typeof e>"u"&&(e=0);const s=["","k","M","G","T","P"],n=Math.floor(Math.log(t)/Math.log(1e3));return typeof s[n]>"u"||s[n]&&s[n]==null?0:(t/Math.pow(1e3,Math.floor(n))).toFixed(e)+" "+s[n]},p=t=>{_(e=>{if(t.difficulty&&(e.difficulty=g(t.difficulty,0).toString(),e.hashRate=d(t.difficulty/240)),t.height&&(e.height=t.height.toString()),t.last_known_block_index&&(e.last_known_block_index=t.last_known_block_index.toString()),t.tx_count&&(e.transactions=t.tx_count.toString()),t.block&&(t.block.baseReward&&(e.currentReward=u(t.block.baseReward,8)),t.block.alreadyGeneratedCoins&&(e.emissionPercent=(t.block.alreadyGeneratedCoins/1e8/336e6*100).toFixed(2).toString(),e.supply=u(t.block.alreadyGeneratedCoins).toString())),t.blocks){const s=[];for(let n=t.blocks.length-1;n>=0;n--){const r=t.blocks[n];if(r&&r.difficulty&&s.push(parseInt(r.difficulty)),n===0){const i=s.reduce(b,0),a=Math.round(i/s.length),c=a/240;e.avgDifficulty=g(a,0).toString(),e.avgHashrate=d(c),e.blockSolveTime=y(t.difficulty/c),e.blocks=[...t.blocks]}}}return e.lastUnixTime=new Date().getTime(),e})},f=async(t,e)=>{if(t&&e){const s=await fetch(t,e).then(n=>n.json());if(s)return s.height||s.result?s.result?{res:s.result}:{res:s}:{error:"no result"}}else return{error:"needs: url and config object"}},w=async t=>{const e=await f(t+"/getinfo",{method:"GET"});if(e&&(e.error||e.res))return e},T=async(t,e)=>{const s=await f(t+"/json_rpc",{method:"POST",body:JSON.stringify({jsonrpc:"2.0",id:"test",method:"f_block_json",params:{hash:e.toString()}})});if(s&&(s.error||s.res))return s},x=async(t,e)=>{const s=await f(t+"/json_rpc",{method:"POST",body:JSON.stringify({jsonrpc:"2.0",id:"test",method:"f_blocks_list_json",params:{height:Number(e)}})});if(s&&(s.error||s.res))return s},o=Object.assign({});o.startStats=async t=>{const{url:e,callback:s}=t,n=await w(e);if(n){if(n.error)return!0;if(n.res){const r=n.res,i=await T(e,r.last_known_block_index);if(i){if(i.error)return!0;if(i.res){const a=i.res,c=await x(e,r.last_known_block_index);if(c){if(c.error)return!0;if(c.res)return p({...r,...a,...c.res}),s(e,5e3),!0}}}}}};o.loop=(t,e)=>{const s=new Date().getTime();l?k.lastUnixTime+e>=s-300?l=setTimeout(()=>o.startStats({url:t,callback:o.loop}),e):(clearTimeout(l),l=setTimeout(()=>o.startStats({url:t,callback:o.loop}),e*2)):l=setTimeout(()=>o.startStats({url:t,callback:o.loop}),e)};const H=async t=>t?(await o.startStats({url:t,callback:o.loop}),!0):!1,S=()=>clearTimeout(l),D={subscribe:m,init:H,stop:S};export{D as s};
